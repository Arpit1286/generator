package com.cloudwick.generator.retail

import java.io.File
import java.util.Locale
import java.util.concurrent.atomic.AtomicLong
import com.cloudwick.generator.utils._

import com.cloudwick.generator.utils.LazyLogging
import org.joda.time.{Period, LocalDate}

import scala.collection.mutable.ArrayBuffer

class Writer(storesStartRange: Int,
  storesEndRage: Int,
  startDate: LocalDate,
  endDate: LocalDate,
  totalDays: Int,
  counter: AtomicLong,
  sizeCounter: AtomicLong,
  config: OptionsConfig) extends Runnable with LazyLogging {

  lazy val utils = new Utils
  lazy val dateUtils = new DateUtils
  lazy val sleepTime = if(config.eventsPerSec == 0) 0 else 1000/config.eventsPerSec

  def threadName = Thread.currentThread().getName

  def run() = {
    val totalStores = storesEndRage - storesStartRange + 1
    var batchCount: Int = 0
    val totalEvents = totalStores * config.productsCount * totalDays
    val outputFile = new File(config.filePath, s"mock_retail_$threadName.data").toString
    var eventsText  = new ArrayBuffer[String](config.flushBatch)
    var fileHandlerText: FileHandler = null
    var retailEvent: RetailEvent = null

    logger.debug("Initializing thread: {} ({} - {})", threadName, storesStartRange.toString, storesEndRage.toString)

    try {
      fileHandlerText = new FileHandler(outputFile, config.fileRollSize)
      fileHandlerText.openFile()

      val range = dateUtils.dateRange(startDate, endDate, new Period().withDays(1)).toList
      var inventory = 0
      var unitSale = 0

      // Start generating events
      (storesStartRange to storesEndRage).foreach { storeId =>
        (1 to config.productsCount).foreach { productId =>
          range.foreach { d =>
            Thread.sleep(sleepTime)
            batchCount += 1

            val dayOfWeek = d.dayOfWeek().getAsText(Locale.ENGLISH)
            dayOfWeek match {
              case "Sunday" =>
                inventory = 100
                unitSale = utils.randInt(0, inventory)
              case _ =>
                if (inventory > 0) {
                  inventory = inventory - unitSale
                  unitSale = utils.randInt(0, inventory)
                } else {
                  inventory = 0
                  unitSale = 0
                }
            }

            retailEvent = RetailEvent(storeId, productId, d, inventory, unitSale)
            sizeCounter.getAndAdd(retailEvent.toString.getBytes.length)
            eventsText += retailEvent.toString
            counter.getAndIncrement()
            if (batchCount == config.flushBatch || batchCount == totalEvents) {
              fileHandlerText.publishBuffered(eventsText)
              eventsText.clear()
              batchCount = 0
            }
          }
        }
      }
      logger.debug(s"Events generated by $threadName is: $totalEvents from ($storesStartRange) to ($storesEndRage)")
    } catch {
      case e: Exception => logger.error("Error:: {}", e)
    } finally {
      fileHandlerText.close()
    }

  }
}
